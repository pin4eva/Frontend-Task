"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var Bluebird = require("bluebird");
var c = require("chalk");
var execa_1 = require("execa");
var inquirer = require("inquirer");
var path_1 = require("path");
function getDependencies(_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.selection, selection = _c === void 0 ? 'all' : _c, packageJson = _b.packageJson;
    packageJson = packageJson || require(path_1.join(process.cwd(), 'package.json'));
    var selections = {
        dependencies: packageJson.dependencies || {},
        devDependencies: packageJson.devDependencies || {},
        all: __assign({}, packageJson.devDependencies || {}, packageJson.dependencies || {}),
    };
    var selected = selections[selection];
    var keys = Object.keys(selected)
        .filter(function (key) { return !/^@types\//.test(key); });
    return { keys: keys, selected: selected, selections: selections };
}
exports.getDependencies = getDependencies;
function getYarnVersion() {
    return __awaiter(this, void 0, void 0, function () {
        var result, ex_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, execa_1.shell('yarn --version')];
                case 1:
                    result = _a.sent();
                    return [2 /*return*/, result.stdout];
                case 2:
                    ex_1 = _a.sent();
                    return [2 /*return*/, ''];
                case 3: return [2 /*return*/];
            }
        });
    });
}
/** @mything/banana becomes mything__banana */
var normalizeName = function (name) {
    return /^@/.test(name)
        ? name.slice(1).split('/').join('__')
        : name;
};
var getTypeDepName = function (name) { return "@types/" + normalizeName(name); };
function installTypes(dependencies, _a) {
    var selections = _a.selections, _b = _a.toDev, toDev = _b === void 0 ? false : _b, _c = _a.pwd, pwd = _c === void 0 ? '' : _c, _d = _a.concurrency, concurrency = _d === void 0 ? 1 : _d, packageManager = _a.packageManager;
    return __awaiter(this, void 0, void 0, function () {
        var installCommand, directory, installs;
        var _this = this;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0: return [4 /*yield*/, (function () { return __awaiter(_this, void 0, void 0, function () {
                        var _a;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    if (packageManager === 'pnpm') {
                                        return [2 /*return*/, 'pnpm install'];
                                    }
                                    _a = packageManager;
                                    if (_a) return [3 /*break*/, 2];
                                    return [4 /*yield*/, getYarnVersion()];
                                case 1:
                                    _a = ((_b.sent()) ? 'yarn' : 'npm');
                                    _b.label = 2;
                                case 2:
                                    packageManager = _a;
                                    if (packageManager === 'yarn') {
                                        return [2 /*return*/, 'yarn add'];
                                    }
                                    return [2 /*return*/, 'npm install'];
                            }
                        });
                    }); })()];
                case 1:
                    installCommand = _e.sent();
                    directory = pwd ? "cd " + pwd + " &&" : '';
                    return [4 /*yield*/, Bluebird.map(dependencies, function (actualName) { return __awaiter(_this, void 0, void 0, function () {
                            var typeDep, saveTo, stdout, err_1;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        typeDep = getTypeDepName(actualName);
                                        saveTo = toDev || (actualName in selections.devDependencies) ? '--dev' : '';
                                        _a.label = 1;
                                    case 1:
                                        _a.trys.push([1, 3, , 4]);
                                        return [4 /*yield*/, execa_1.shell(directory + " " + installCommand + " " + saveTo + " " + typeDep, {
                                                env: __assign({}, process.env, { FORCE_COLOR: true }),
                                            })];
                                    case 2:
                                        stdout = (_a.sent()).stdout;
                                        console.log(c.green(typeDep), 'found');
                                        console.log('\n', stdout, '\n');
                                        return [3 /*break*/, 4];
                                    case 3:
                                        err_1 = _a.sent();
                                        console.log(c.yellow(typeDep), 'not found or failed to install');
                                        if (process.env.DEBUG) {
                                            console.error(c.red(err_1));
                                        }
                                        return [3 /*break*/, 4];
                                    case 4: return [2 /*return*/];
                                }
                            });
                        }); }, { concurrency: concurrency })];
                case 2:
                    installs = _e.sent();
                    return [2 /*return*/, installs];
            }
        });
    });
}
exports.installTypes = installTypes;
exports.install = function (_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.selection, selection = _c === void 0 ? 'all' : _c, _d = _b.toDev, toDev = _d === void 0 ? false : _d, _e = _b.deps, deps = _e === void 0 ? '' : _e;
    return __awaiter(_this, void 0, void 0, function () {
        var results, selections, keys;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    if (deps) {
                        console.log("Installing dependency " + c.cyan.bold(deps || selection) + " in @types");
                    }
                    else {
                        console.log("Installing " + c.cyan.bold(selection) + " in @types");
                    }
                    results = getDependencies({ selection: selection });
                    selections = results.selections;
                    keys = results.keys;
                    if (deps) {
                        keys = keys.filter(function (key) { return key === deps; });
                    }
                    if (!keys.length) {
                        console.error(c.yellow('No dependencies to install'));
                        return [2 /*return*/];
                    }
                    return [4 /*yield*/, installTypes(keys, { toDev: toDev, selections: selections })];
                case 1:
                    _f.sent();
                    return [2 /*return*/];
            }
        });
    });
};
exports.interactiveInstall = function () { return __awaiter(_this, void 0, void 0, function () {
    var _a, selection, toDev, packageManager, _b, keys, selections, selectedKeys;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0: return [4 /*yield*/, inquirer.prompt([
                    {
                        type: 'list',
                        name: 'selection',
                        message: "Install options:",
                        default: 0,
                        choices: [
                            'all',
                            'dependencies',
                            'devDependencies',
                        ],
                    },
                    {
                        type: 'confirm',
                        name: 'toDev',
                        message: "Install all @types/* to " + c.cyan('devDependencies') + "?",
                        default: false,
                    },
                    {
                        type: 'list',
                        name: 'packageManager',
                        message: "Which package manager?:",
                        default: 'yarn',
                        choices: ['yarn', 'npm', 'pnpm'],
                    },
                ])];
            case 1:
                _a = _c.sent(), selection = _a.selection, toDev = _a.toDev, packageManager = _a.packageManager;
                _b = getDependencies({ selection: selection }), keys = _b.keys, selections = _b.selections;
                if (!keys.length) {
                    console.error(c.yellow('No dependencies to install'));
                    return [2 /*return*/];
                }
                console.log("Installing " + c.cyan.bold(selection) + " @type dependencies...");
                console.log();
                return [4 /*yield*/, inquirer.prompt([
                        {
                            type: 'checkbox',
                            name: 'selectedKeys',
                            message: 'select',
                            choices: keys.map(function (depName) {
                                var typeDep = getTypeDepName(depName);
                                var isAlreadyTyped = typeDep in selections.all;
                                return {
                                    name: depName + " " + (isAlreadyTyped ? c.grey("(Installed: " + typeDep + ")") : ''),
                                    value: depName,
                                    checked: true,
                                };
                            }),
                        },
                    ])];
            case 2:
                selectedKeys = (_c.sent()).selectedKeys;
                return [4 /*yield*/, installTypes(selectedKeys, { toDev: toDev, selections: selections, packageManager: packageManager })];
            case 3:
                _c.sent();
                return [2 /*return*/];
        }
    });
}); };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWN0aW9ucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9hY3Rpb25zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaUJBMkxBOztBQTNMQSxtQ0FBcUM7QUFDckMseUJBQTJCO0FBQzNCLCtCQUE4QjtBQUM5QixtQ0FBcUM7QUFDckMsNkJBQTRCO0FBVzVCLFNBQWdCLGVBQWUsQ0FDN0IsRUFHTTtRQUhOLDRCQUdNLEVBSEosaUJBQWlCLEVBQWpCLHNDQUFpQixFQUFFLDRCQUFXO0lBSWhDLFdBQVcsR0FBRyxXQUFXLElBQUksT0FBTyxDQUFDLFdBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQztJQUUxRSxJQUFNLFVBQVUsR0FBZ0I7UUFDOUIsWUFBWSxFQUFFLFdBQVcsQ0FBQyxZQUFZLElBQUksRUFBRTtRQUM1QyxlQUFlLEVBQUUsV0FBVyxDQUFDLGVBQWUsSUFBSSxFQUFFO1FBQ2xELEdBQUcsZUFDRSxXQUFXLENBQUMsZUFBZSxJQUFJLEVBQUUsRUFDakMsV0FBVyxDQUFDLFlBQVksSUFBSSxFQUFFLENBQ2xDO0tBQ0YsQ0FBQztJQUVGLElBQU0sUUFBUSxHQUFHLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUV2QyxJQUFNLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztTQUMvQixNQUFNLENBQUMsVUFBQyxHQUFHLElBQUssT0FBQSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQXRCLENBQXNCLENBQUMsQ0FBQztJQUUzQyxPQUFPLEVBQUUsSUFBSSxNQUFBLEVBQUUsUUFBUSxVQUFBLEVBQUUsVUFBVSxZQUFBLEVBQUUsQ0FBQztBQUN4QyxDQUFDO0FBdEJELDBDQXNCQztBQUVELFNBQWUsY0FBYzs7Ozs7OztvQkFFVixxQkFBTSxh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LENBQUM7d0JBQzdDOzRCQUNFLElBQUksRUFBRSxVQUFVOzRCQUNoQixJQUFJLEVBQUUsY0FBYzs0QkFDcEIsT0FBTyxFQUFFLFFBQVE7NEJBQ2pCLE9BQU8sRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQUMsT0FBTztnQ0FDeEIsSUFBTSxPQUFPLEdBQUcsY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dDQUN4QyxJQUFNLGNBQWMsR0FBRyxPQUFPLElBQUksVUFBVSxDQUFDLEdBQUcsQ0FBQztnQ0FFakQsT0FBTztvQ0FDTCxJQUFJLEVBQUssT0FBTyxVQUFJLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxpQkFBZSxPQUFPLE1BQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUU7b0NBQzdFLEtBQUssRUFBRSxPQUFPO29DQUNkLE9BQU8sRUFBRSxJQUFJO2lDQUNkLENBQUM7NEJBQ0osQ0FBQyxDQUFDO3lCQUNIO3FCQUNGLENBQUMsRUFBQTs7Z0JBaEJNLFlBQVksR0FBSyxDQUFBLFNBZ0J2QixDQUFBLGFBaEJrQjtnQkFrQnBCLHFCQUFNLFlBQVksQ0FBQyxZQUFZLEVBQUUsRUFBRSxLQUFLLE9BQUEsRUFBRSxVQUFVLFlBQUEsRUFBRSxjQUFjLGdCQUFBLEVBQUUsQ0FBQyxFQUFBOztnQkFBdkUsU0FBdUUsQ0FBQzs7OztLQUN6RSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQmx1ZWJpcmQgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0ICogYXMgYyBmcm9tICdjaGFsayc7XG5pbXBvcnQgeyBzaGVsbCB9IGZyb20gJ2V4ZWNhJztcbmltcG9ydCAqIGFzIGlucXVpcmVyIGZyb20gJ2lucXVpcmVyJztcbmltcG9ydCB7IGpvaW4gfSBmcm9tICdwYXRoJztcblxuLy8gdHNsaW50OmRpc2FibGU6bm8tY29uc29sZVxuXG5leHBvcnQgaW50ZXJmYWNlIElEZXBlbmRlbmNpZXMgeyBba2V5OiBzdHJpbmddOiBzdHJpbmc7IH1cbmV4cG9ydCBpbnRlcmZhY2UgSVNlbGVjdGlvbnMge1xuICBkZXBlbmRlbmNpZXM6IElEZXBlbmRlbmNpZXM7XG4gIGRldkRlcGVuZGVuY2llczogSURlcGVuZGVuY2llcztcbiAgYWxsOiBJRGVwZW5kZW5jaWVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVwZW5kZW5jaWVzIChcbiAgeyBzZWxlY3Rpb24gPSAnYWxsJywgcGFja2FnZUpzb24gfToge1xuICAgIHNlbGVjdGlvbj86IGtleW9mIElTZWxlY3Rpb25zLFxuICAgIHBhY2thZ2VKc29uPzogYW55LFxuICB9ID0ge30pIHtcbiAgcGFja2FnZUpzb24gPSBwYWNrYWdlSnNvbiB8fCByZXF1aXJlKGpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3BhY2thZ2UuanNvbicpKTtcblxuICBjb25zdCBzZWxlY3Rpb25zOiBJU2VsZWN0aW9ucyA9IHtcbiAgICBkZXBlbmRlbmNpZXM6IHBhY2thZ2VKc29uLmRlcGVuZGVuY2llcyB8fCB7fSxcbiAgICBkZXZEZXBlbmRlbmNpZXM6IHBhY2thZ2VKc29uLmRldkRlcGVuZGVuY2llcyB8fCB7fSxcbiAgICBhbGw6IHtcbiAgICAgIC4uLnBhY2thZ2VKc29uLmRldkRlcGVuZGVuY2llcyB8fCB7fSxcbiAgICAgIC4uLnBhY2thZ2VKc29uLmRlcGVuZGVuY2llcyB8fCB7fSxcbiAgICB9LFxuICB9O1xuXG4gIGNvbnN0IHNlbGVjdGVkID0gc2VsZWN0aW9uc1tzZWxlY3Rpb25dO1xuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzZWxlY3RlZClcbiAgICAuZmlsdGVyKChrZXkpID0+ICEvXkB0eXBlc1xcLy8udGVzdChrZXkpKTtcblxuICByZXR1cm4geyBrZXlzLCBzZWxlY3RlZCwgc2VsZWN0aW9ucyB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRZYXJuVmVyc2lvbiAoKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2hlbGwoJ3lhcm4gLS12ZXJzaW9uJyk7XG4gICAgcmV0dXJuIHJlc3VsdC5zdGRvdXQ7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUluc3RhbGxPcHRpb25zIHtcbiAgdG9EZXY/OiBib29sZWFuO1xuICBzZWxlY3Rpb24/OiBrZXlvZiBJU2VsZWN0aW9ucztcbiAgcGFja2FnZU1hbmFnZXI/OiAnbnBtJyB8ICd5YXJuJyB8ICdwbnBtJztcbiAgZGVwcz86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJSW5zdGFsbFR5cGVzT3B0aW9ucyBleHRlbmRzIElJbnN0YWxsT3B0aW9ucyB7XG4gIHNlbGVjdGlvbnM6IElTZWxlY3Rpb25zO1xuICBwd2Q/OiBzdHJpbmc7XG4gIGNvbmN1cnJlbmN5PzogbnVtYmVyO1xufVxuXG4vKiogQG15dGhpbmcvYmFuYW5hIGJlY29tZXMgbXl0aGluZ19fYmFuYW5hICovXG5jb25zdCBub3JtYWxpemVOYW1lID0gKG5hbWU6IHN0cmluZykgPT5cbiAgL15ALy50ZXN0KG5hbWUpXG4gICAgPyBuYW1lLnNsaWNlKDEpLnNwbGl0KCcvJykuam9pbignX18nKVxuICAgIDogbmFtZTtcblxuY29uc3QgZ2V0VHlwZURlcE5hbWUgPSAobmFtZTogc3RyaW5nKSA9PiBgQHR5cGVzLyR7bm9ybWFsaXplTmFtZShuYW1lKX1gO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5zdGFsbFR5cGVzIChcbiAgZGVwZW5kZW5jaWVzOiBzdHJpbmdbXSxcbiAgeyBzZWxlY3Rpb25zLCB0b0RldiA9IGZhbHNlLCBwd2QgPSAnJywgY29uY3VycmVuY3kgPSAxLCBwYWNrYWdlTWFuYWdlciB9OiBJSW5zdGFsbFR5cGVzT3B0aW9ucyxcbikge1xuXG4gIGNvbnN0IGluc3RhbGxDb21tYW5kID0gYXdhaXQgKGFzeW5jICgpID0+IHtcbiAgICBpZiAocGFja2FnZU1hbmFnZXIgPT09ICdwbnBtJykgeyByZXR1cm4gJ3BucG0gaW5zdGFsbCc7IH1cblxuICAgIHBhY2thZ2VNYW5hZ2VyID0gcGFja2FnZU1hbmFnZXIgfHwgKGF3YWl0IGdldFlhcm5WZXJzaW9uKCkgPyAneWFybicgOiAnbnBtJyk7XG5cbiAgICBpZiAocGFja2FnZU1hbmFnZXIgPT09ICd5YXJuJykgeyByZXR1cm4gJ3lhcm4gYWRkJzsgfVxuXG4gICAgcmV0dXJuICducG0gaW5zdGFsbCc7XG4gIH0pKCk7XG5cbiAgY29uc3QgZGlyZWN0b3J5ID0gcHdkID8gYGNkICR7cHdkfSAmJmAgOiAnJztcblxuICBjb25zdCBpbnN0YWxscyA9IGF3YWl0IEJsdWViaXJkLm1hcChkZXBlbmRlbmNpZXMsIGFzeW5jIChhY3R1YWxOYW1lKSA9PiB7XG4gICAgY29uc3QgdHlwZURlcCA9IGdldFR5cGVEZXBOYW1lKGFjdHVhbE5hbWUpO1xuICAgIGNvbnN0IHNhdmVUbyA9IHRvRGV2IHx8IChhY3R1YWxOYW1lIGluIHNlbGVjdGlvbnMuZGV2RGVwZW5kZW5jaWVzKSA/ICctLWRldicgOiAnJztcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHN0ZG91dCB9ID0gYXdhaXQgc2hlbGwoYCR7ZGlyZWN0b3J5fSAke2luc3RhbGxDb21tYW5kfSAke3NhdmVUb30gJHt0eXBlRGVwfWAsIHtcbiAgICAgICAgZW52OiB7IC4uLnByb2Nlc3MuZW52LCBGT1JDRV9DT0xPUjogdHJ1ZSB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKGMuZ3JlZW4odHlwZURlcCksICdmb3VuZCcpO1xuICAgICAgY29uc29sZS5sb2coJ1xcbicsIHN0ZG91dCwgJ1xcbicpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5sb2coYy55ZWxsb3codHlwZURlcCksICdub3QgZm91bmQgb3IgZmFpbGVkIHRvIGluc3RhbGwnKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5ERUJVRykgeyBjb25zb2xlLmVycm9yKGMucmVkKGVycikpOyB9XG4gICAgfVxuICB9LCB7IGNvbmN1cnJlbmN5IH0pO1xuXG4gIHJldHVybiBpbnN0YWxscztcbn1cblxuZXhwb3J0IGNvbnN0IGluc3RhbGwgPSBhc3luYyAoeyBzZWxlY3Rpb24gPSAnYWxsJywgdG9EZXYgPSBmYWxzZSwgZGVwcyA9ICcnIH06IElJbnN0YWxsT3B0aW9ucyA9IHt9KSA9PiB7XG4gIGlmIChkZXBzKSB7XG4gICAgY29uc29sZS5sb2coYEluc3RhbGxpbmcgZGVwZW5kZW5jeSAke2MuY3lhbi5ib2xkKGRlcHMgfHwgc2VsZWN0aW9uKX0gaW4gQHR5cGVzYCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2coYEluc3RhbGxpbmcgJHtjLmN5YW4uYm9sZChzZWxlY3Rpb24pfSBpbiBAdHlwZXNgKTtcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdHMgPSBnZXREZXBlbmRlbmNpZXMoeyBzZWxlY3Rpb24gfSk7XG4gIGNvbnN0IHsgc2VsZWN0aW9ucyB9ID0gcmVzdWx0cztcbiAgbGV0IHsga2V5cyB9ID0gcmVzdWx0cztcblxuICBpZiAoZGVwcykge1xuICAgIGtleXMgPSBrZXlzLmZpbHRlcigoa2V5KSA9PiBrZXkgPT09IGRlcHMpO1xuICB9XG5cbiAgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgIGNvbnNvbGUuZXJyb3IoYy55ZWxsb3coJ05vIGRlcGVuZGVuY2llcyB0byBpbnN0YWxsJykpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGF3YWl0IGluc3RhbGxUeXBlcyhrZXlzLCB7IHRvRGV2LCBzZWxlY3Rpb25zIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGludGVyYWN0aXZlSW5zdGFsbCA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24sIHRvRGV2LCBwYWNrYWdlTWFuYWdlciB9ID0gYXdhaXQgaW5xdWlyZXIucHJvbXB0KFtcbiAgICB7XG4gICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICBuYW1lOiAnc2VsZWN0aW9uJyxcbiAgICAgIG1lc3NhZ2U6IGBJbnN0YWxsIG9wdGlvbnM6YCxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICBjaG9pY2VzOiBbXG4gICAgICAgICdhbGwnLFxuICAgICAgICAnZGVwZW5kZW5jaWVzJyxcbiAgICAgICAgJ2RldkRlcGVuZGVuY2llcycsXG4gICAgICBdLFxuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogJ2NvbmZpcm0nLFxuICAgICAgbmFtZTogJ3RvRGV2JyxcbiAgICAgIG1lc3NhZ2U6IGBJbnN0YWxsIGFsbCBAdHlwZXMvKiB0byAke2MuY3lhbignZGV2RGVwZW5kZW5jaWVzJyl9P2AsXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgIG5hbWU6ICdwYWNrYWdlTWFuYWdlcicsXG4gICAgICBtZXNzYWdlOiBgV2hpY2ggcGFja2FnZSBtYW5hZ2VyPzpgLFxuICAgICAgZGVmYXVsdDogJ3lhcm4nLFxuICAgICAgY2hvaWNlczogWyd5YXJuJywgJ25wbScsICdwbnBtJ10gYXMgQXJyYXk8UmVxdWlyZWQ8SUluc3RhbGxPcHRpb25zPlsncGFja2FnZU1hbmFnZXInXT4sXG4gICAgfSxcbiAgXSk7XG5cbiAgY29uc3QgeyBrZXlzLCBzZWxlY3Rpb25zIH0gPSBnZXREZXBlbmRlbmNpZXMoeyBzZWxlY3Rpb24gfSk7XG5cbiAgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgIGNvbnNvbGUuZXJyb3IoYy55ZWxsb3coJ05vIGRlcGVuZGVuY2llcyB0byBpbnN0YWxsJykpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnNvbGUubG9nKGBJbnN0YWxsaW5nICR7Yy5jeWFuLmJvbGQoc2VsZWN0aW9uKX0gQHR5cGUgZGVwZW5kZW5jaWVzLi4uYCk7XG4gIGNvbnNvbGUubG9nKCk7XG5cbiAgY29uc3QgeyBzZWxlY3RlZEtleXMgfSA9IGF3YWl0IGlucXVpcmVyLnByb21wdChbXG4gICAge1xuICAgICAgdHlwZTogJ2NoZWNrYm94JyxcbiAgICAgIG5hbWU6ICdzZWxlY3RlZEtleXMnLFxuICAgICAgbWVzc2FnZTogJ3NlbGVjdCcsXG4gICAgICBjaG9pY2VzOiBrZXlzLm1hcCgoZGVwTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCB0eXBlRGVwID0gZ2V0VHlwZURlcE5hbWUoZGVwTmFtZSk7XG4gICAgICAgIGNvbnN0IGlzQWxyZWFkeVR5cGVkID0gdHlwZURlcCBpbiBzZWxlY3Rpb25zLmFsbDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IGAke2RlcE5hbWV9ICR7aXNBbHJlYWR5VHlwZWQgPyBjLmdyZXkoYChJbnN0YWxsZWQ6ICR7dHlwZURlcH0pYCkgOiAnJ31gLFxuICAgICAgICAgIHZhbHVlOiBkZXBOYW1lLFxuICAgICAgICAgIGNoZWNrZWQ6IHRydWUsXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICB9LFxuICBdKTtcblxuICBhd2FpdCBpbnN0YWxsVHlwZXMoc2VsZWN0ZWRLZXlzLCB7IHRvRGV2LCBzZWxlY3Rpb25zLCBwYWNrYWdlTWFuYWdlciB9KTtcbn07XG4iXX0=